# -*- coding: utf-8 -*-

""" Script generators for ddionrails.workspace app: SoepR """

from typing import Dict

from ..mixins import SoepMixin
from .script_config import ScriptConfig
from .soep_config import SoepConfig


def add_wave_variables(variable_list, wave_mapping):
    for prefix, year in wave_mapping.items():
        variable_list.append(f'"hid_{year}"')
        variable_list.append(f'"{prefix}netto"')
        variable_list.append(f'"{prefix}pop"')
    return variable_list


class SoepR(SoepConfig, ScriptConfig, SoepMixin):
    """Script Generator for R scripts"""

    NAME = "soep-r"
    COMMENT = "#"

    def get_script_input(self) -> Dict:
        script_input = super().get_script_input()
        script_dict = self.script_dict
        script_input["script_dict"] = script_dict
        script_input["years"] = self.years
        script_input["valid_datasets"] = self._validate_datasets(
            self.script_dict_raw, self.settings["analysis_unit"]
        )
        not_processed_datasets = self._validate_datasets(
            self.script_dict_raw, self.settings["analysis_unit"], valid=False
        )
        script_input["not_processed"] = {
            x: y for x, y in script_input["data"].items() if x in not_processed_datasets
        }
        script_input["is_special"] = {
            x: y
            for x, y in script_input["data"].items()
            if x in {"hhrf", "phrf", "ppfad", "hpfad"}
        }

        script_input["text"] = "\n".join(
            [
                self._render_disclaimer(),
                self._render_local_variables(),
                self._render_not_processed(script_input["not_processed"]),
                self._render_pfad(script_input["is_special"]),
                self._render_balanced(),
                self._render_private(),
                self._render_gender(),
                self._render_sort_pfad(),
                self._render_hrf(script_input["is_special"]),
                self._render_create_main(),
                self._render_read_data(),
                self._render_merge(),
                self._render_done(),
            ]
        )
        return script_input

    def _render_disclaimer(self) -> str:
        """Render the disclaimer of the script file"""
        return (
            "\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
            f"{self.COMMENT} This command file was generated by paneldata.org                    .\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
            f"{self.COMMENT} !!! I M P O R T A N T - W A R N I N G !!!                           .\n"
            f"{self.COMMENT} You alone are responsible for contents and appropriate.             .\n"
            f"{self.COMMENT} usage by accepting the usage agreement.                             .\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
            f"{self.COMMENT} Please report any errors of the code generated here                 .\n"
            f"{self.COMMENT} to soepmail@diw.de                                                  .\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
        )

    def _render_local_variables(self) -> str:
        """Render a "local variables" section of the script file"""
        script = '\nlibrary("haven")'
        script += "\n### LOCAL VARIABLES ###"
        script += '\npath_in <- "%s"' % self.settings["path_in"].replace("\\", "/")
        script += '\npath_out <- "%s"' % self.settings["path_out"].replace("\\", "/")
        return script

    def _render_not_processed(self, not_processed) -> str:
        """Render a "not processed" section of the script file"""
        heading = "\n\n%s* * * NOT PROCESSED * * *.\n" % self.COMMENT
        script = ""
        for key, value in not_processed.items():
            script += "%s From datasets '%s': %s.\n" % (self.COMMENT, key, value)
        return heading + script

    def _render_pfad(self, special_datasets) -> str:
        """Render a "load pfad" section of the script file"""
        script = "\n### LOAD [H|P]PFAD ###\n"
        if self.settings["analysis_unit"] == "p":
            script += '\npfad <- read_dta(file.path(path_in, "ppfad.dta"))'
            temp = ['"cid"', '"pid"', '"sex"', '"gebjahr"', '"psample"']
            temp = add_wave_variables(temp, self.years_mapping)
            if "ppfad" in special_datasets:
                for variable in special_datasets["ppfad"]:
                    temp.append('"%s"' % variable)
        else:
            script += '\npfad <- read_dta(file.path(path_in, "hpfad.dta"))'
            temp = ['"cid"', '"hid"', '"hsample"']
            temp = add_wave_variables(temp, self.years_mapping)
            if "hpfad" in special_datasets:
                for variable in special_datasets["hpfad"]:
                    temp.append('"%s"' % variable)
        joined = ", ".join(list(set(temp)))
        script += "\npfad <- pfad[ , c(%s)]" % joined
        return script

    def _render_balanced(self) -> str:
        """Render a "balanced" section of the script file"""
        heading = "\n### [UN]BALANCED ###\n"
        connector = "&" if self.settings["balanced"] == "t" else "|"
        if self.settings["analysis_unit"] == "p":
            temp = []
            for year in self.years:
                if self.settings["age_group"] == "adult":
                    temp.append(" (%snetto >= 10 & %snetto < 20) " % (year, year))
                elif self.settings["age_group"] == "no17":
                    temp.append(" (%snetto >= 10 & %snetto < 16) " % (year, year))
                else:
                    temp.append(" (%snetto > 0 & %snetto < 40) " % (year, year))
            return heading + "\npfad <- with(pfad, pfad[" + connector.join(temp) + ", ])"
        temp = []
        for year in self.years:
            temp.append(" (%shnetto == 1) " % year)
        return heading + "\npfad <- with(pfad, pfad[" + connector.join(temp) + ", ])"

    def _render_private(self) -> str:
        """Render a "private households" section of the script file"""
        heading = "\n### PRIVATE HOUSEHOLDS ###\n"
        set_name = "pop" if self.settings["analysis_unit"] == "p" else "hpop"
        if self.settings["private"] == "t":
            temp = []
            for year in self.years:
                temp.append(" (%s%s == 1 | %s%s == 2)" % (year, set_name, year, set_name))
            return heading + "\npfad <- with(pfad, pfad[" + "|".join(temp) + ", ])"
        return heading + "\n# all households"

    def _render_gender(self) -> str:
        """Render a "gender" section of the script file"""
        if self.settings["analysis_unit"] == "p":
            heading = "\n### GENDER ( male = 1 / female = 2) ###\n"
            gender = self.settings.get("gender", "b")
            if gender == "m":
                return heading + "\npfad <- pfad[pfad$sex==1,]"
            if gender == "f":
                return heading + "\npfad <- pfad[pfad$sex==2,]"
            return heading + "\n# all genders"
        return "\n### GENDER NOT FOR HOUSEHOLDS ###\n"

    @staticmethod
    def _render_sort_pfad() -> str:
        """Render a "sort pfad" section of the script file"""
        script = "\n### SORT [H|P]PFAD ###\n"
        script += "\n# This is R -- no sorting neccessary :-)"
        script += "\n"
        return script

    def _render_hrf(self, special_datasets) -> str:
        """Render a "load hrf" section of the script file"""
        script = "\n### LOAD [H|P]HRF ###\n"
        if self.settings["analysis_unit"] == "p":
            script += '\nhrf <- read_dta(file.path(path_in, "phrf.dta"))'
            temp = []
            temp.append('"cid"')
            temp.append('"pid"')
            temp.append('"prgroup"')
            for year in self.years:
                temp.append('"{}phrf"'.format(year))
            if "phrf" in special_datasets:
                for variable in special_datasets["phrf"]:
                    temp.append('"{}"'.format(variable))
            script += "\nhrf <- hrf[,c(" + ", ".join(list(set(temp))) + ")]"
        else:
            script += '\nhrf <- read_dta(file.path(path_in, "hhrf.dta"))'
            temp = []
            temp.append('"cid"')
            temp.append('"hid"')
            temp.append('"hrgroup"')
            for year in self.years:
                temp.append('"{}hhrf"'.format(year))
            if "hhrf" in special_datasets:
                for variable in special_datasets["hhrf"]:
                    temp.append('"{}"'.format(variable))
            script += "\nhrf <- hrf[,c(" + ", ".join(list(set(temp))) + ")]"
        return script

    def _render_create_main(self) -> str:
        """Render a "create main" section of the script file"""
        key = "pid" if self.settings["analysis_unit"] == "p" else "hid"
        script = "\n### CREATE MAIN ###\n"
        script += '\nmain <- merge( pfad, hrf, by = c("%s", "cid"))' % key
        return script

    def _render_read_data(self) -> str:
        """Render a "read data" section of the script file"""
        heading = "\n### READ DATA ###\n"
        temp = ["\ndata <- list()"]
        for dataset in self.script_dict.values():
            if dataset["is_special"] == True:
                continue
            list_variables = set.copy(dataset["variables"])
            if dataset["analysis_unit"] == "p":
                for var in dataset["variables"]:
                    if var.startswith("hid_"):
                        list_variables.remove(var)
            script = "\ntmp_variables <- c(%s)" % ", ".join(
                ['"%s"' % x for x in list_variables]
            )
            script += (
                '\ntmp_dataset <- read_dta(file.path(path_in, "%s.dta"))'
                % dataset["name"]
            )
            script += '\ndata[["%s"]] <- tmp_dataset[ , tmp_variables]' % dataset["name"]
            temp.append(script)
        return heading + "\n\n".join(temp)

    def _render_merge(self) -> str:
        """Render a "merge" section of the script file"""
        script = "\n### MERGE ###\n"
        for dataset in self.script_dict.values():
            if dataset["is_special"] == True:
                continue
            script += (
                '\nmain <- merge(main, data[["%s"]], by = "%s", all.x=T, all.y=F)'
                % (dataset["name"], dataset["merge_id"])
            )
        return script

    @staticmethod
    def _render_done() -> str:
        """Render a "done" section of the script file"""
        return (
            "\n"
            "### DONE ###\n\n"
            'attr(main, "label") <- "paneldata.org"\n'
            "str(main)\n"
            'save(main, file=file.path(path_out, "main.RData"))'
        )
