# -*- coding: utf-8 -*-

""" Script generators for ddionrails.workspace app: SoepStata """

from typing import Dict

from ..mixins import SoepMixin
from .script_config import ScriptConfig
from .soep_config import SoepConfig

# from ddionrails.workspace.scripts.soep_datasets import SoepDatasets # only for debug


class SoepStata(SoepConfig, ScriptConfig, SoepMixin):
    """Script Generator for Stata scripts"""

    NAME = "soep-stata"
    COMMENT = "*"

    def get_script_input(self) -> Dict:
        script_input = super().get_script_input()
        script_dict = self.script_dict
        script_input["script_dict"] = script_dict
        script_input["years"] = self.years
        script_input["valid_datasets"] = self._validate_datasets(
            self.script_dict_raw, self.settings["analysis_unit"]
        )
        not_processed_datasets = self._validate_datasets(
            self.script_dict_raw, self.settings["analysis_unit"], valid=False
        )
        script_input["not_processed"] = {
            x: y for x, y in script_input["data"].items() if x in not_processed_datasets
        }
        script_input["is_special"] = {
            x: y
            for x, y in script_input["data"].items()
            if x in {"hhrf", "phrf", "ppfad", "hpfad"}
        }

        script_input["text"] = "\n".join(
            [
                self._render_disclaimer(),
                self._render_local_variables(),
                self._render_not_processed(script_input["not_processed"]),
                self._render_pfad(script_input["is_special"]),
                self._render_balanced(),
                self._render_private(),
                self._render_gender(),
                self._render_sort_pfad(),
                self._render_hrf(script_input["is_special"]),
                self._render_create_master(),
                self._render_read_data(),
                self._render_merge(script_input["is_special"]),
                self._render_done(),
            ]
        )
        return script_input

    def _render_test(self, data, old_valid, old_notp, special):
        """test"""
        heading = "\n\n* * * Debug * * *\n"
        script = "\n {}".format(data)
        script += "\n {}".format(special)
        script += "\n {}".format(self.script_dict.values())
        return heading + script

    def _render_disclaimer(self) -> str:
        """Render the disclaimer of the script file"""
        return (
            "\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
            f"{self.COMMENT} This command file was generated by paneldata.org                    .\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
            f"{self.COMMENT} !!! I M P O R T A N T - W A R N I N G !!!                           .\n"
            f"{self.COMMENT} You alone are responsible for contents and appropriate.             .\n"
            f"{self.COMMENT} usage by accepting the usage agreement.                             .\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
            f"{self.COMMENT} Please report any errors of the code generated here                 .\n"
            f"{self.COMMENT} to soepmail@diw.de                                                  .\n"
            f"{self.COMMENT} --------------------------------------------------------------------.\n"
        )

    def _render_local_variables(self) -> str:
        """Render a "local variables" section of the script file"""
        heading = "\n\n* * * LOCAL VARIABLES * * *\n"
        script = '\nglobal MY_PATH_IN   "%s"' % self.settings["path_in"]
        script += '\nglobal MY_PATH_OUT  "%s"' % self.settings["path_out"]
        script += "\nglobal MY_FILE_OUT  ${MY_PATH_OUT}new.dta"
        script += "\nglobal MY_LOG_FILE  ${MY_PATH_OUT}new.log"
        script += "\ncapture log close"
        script += '\nlog using "${MY_LOG_FILE}", text replace'
        script += "\nset more off"
        return heading + script

    def _render_not_processed(self, not_processed) -> str:
        """Render a "not processed" section of the script file"""
        heading = "\n\n%s* * * NOT PROCESSED * * *.\n" % self.COMMENT
        script = ""
        for key, value in not_processed.items():
            script += "%s From datasets '%s': %s.\n" % (self.COMMENT, key, value)
        return heading + script

    def _render_pfad(self, special_datasets) -> str:
        """Render a "load pfad" section of the script file"""
        heading = "\n\n* * * PFAD * * *\n"
        script = []
        if self.settings["analysis_unit"] == "p":
            script.append("\nuse")
            pfad_variables = ["hid", "persnr", "sex", "gebjahr", "psample"]
            for prefix, year in self.years_mapping.items():
                pfad_variables.append(f"hid_{year}")
                pfad_variables.append(f"{prefix}netto")
                pfad_variables.append(f"{prefix}pop")
            if "ppfad" in special_datasets:
                for variable in special_datasets["ppfad"]:
                    pfad_variables.append(variable)
            script.extend(list(set(pfad_variables)))
            script.append("///")
            script.append('\nusing "${MY_PATH_IN}ppfad.dta", clear')
        else:
            script.append("\nuse /// \nhid cid hsample ///")
            for prefix, year in self.years_mapping.items():
                script.append(f"\nhid_{year} {prefix}hnetto {prefix}hpop ///")
            if "hpfad" in special_datasets:
                for variable in special_datasets["hpfad"]:
                    script.append("\n%s ///" % variable)
            script.append('\nusing "${MY_PATH_IN}hpfad.dta", clear')
        return heading + " ".join(script)

    def _render_balanced(self) -> str:
        """Render a "balanced" section of the script file"""
        heading = "\n\n* * * BALANCED VS UNBALANCED * * *\n"
        connector = "&" if self.settings["balanced"] == "t" else "|"
        if self.settings["analysis_unit"] == "p":
            temp = []
            for year in self.years:
                if self.settings["age_group"] == "adult":
                    temp.append(" (%snetto >= 10 & %snetto < 20) " % (year, year))
                elif self.settings["age_group"] == "no17":
                    temp.append(" (%snetto >= 10 & %snetto < 16) " % (year, year))
                else:
                    temp.append(" (%snetto > 0 & %snetto < 40) " % (year, year))
            return heading + "\nkeep if (" + connector.join(temp) + ")"
        else:
            temp = []
            for year in self.years:
                temp.append(" (%shnetto == 1) " % year)
            return heading + "\nkeep if (" + connector.join(temp) + ")"

    def _render_private(self) -> str:
        """Render a "private households" section of the script file"""
        heading = "\n\n* * * ONLY PRIVATE HOUSEHOLDS * * *\n"
        set_name = "pop" if self.settings["analysis_unit"] == "p" else "hpop"
        temp = []
        if self.settings["private"] == "t":
            for year in self.years:
                temp.append(
                    " (%s%s == 1 | %s%s == 2) " % (year, set_name, year, set_name)
                )
            return heading + "\nkeep if (" + "|".join(temp) + ")"
        else:
            return heading + "\n/* All households */"

    def _render_gender(self) -> str:
        """Render a "gender" section of the script file"""
        if self.settings["analysis_unit"] == "p":
            options = {
                "m": "\nkeep if (sex == 1)",
                "f": "\nkeep if (sex == 2)",
                "b": "\n/* all genders */",
            }
            gender = self.settings.get("gender", "b")
            gender_selection = options[gender]
            return (
                "\n\n* * * GENDER ( male = 1 / female = 2) * * *\n" f"{gender_selection}"
            )
        else:
            return "\n\n* * * GENDER NOT FOR HOUSEHOLDS * * *\n"

    @staticmethod
    def _render_sort_pfad() -> str:
        """Render a "sort pfad" section of the script file"""
        return (
            "\n\n"
            "* * * SAVE PFAD * * *\n\n"
            'save "${MY_PATH_OUT}pfad.dta", replace \nclear'
        )

    def _render_hrf(self, special_datasets) -> str:
        """Render a "load hrf" section of the script file"""
        heading = "\n\n* * * HRF * * *\n"
        script = ["\nuse"]
        hrf_dataset = ""
        if self.settings["analysis_unit"] == "p":
            hrf_variables = ["hhnr", "persnr", "prgroup"]
            hrf_dataset = "phrf.dta"
            for year in self.years:
                hrf_variables.append("{}phrf".format(year))
            if "phrf" in special_datasets:
                for variable in special_datasets["phrf"]:
                    hrf_variables.append("{}".format(variable))
        else:
            hrf_variables = ["hhnr", "hhnrakt", "hrgroup"]
            hrf_dataset = "hhrf.dta"
            for year in self.years:
                hrf_variables.append("{}hhrf".format(year))
            if "hhrf" in special_datasets:
                for variable in special_datasets["hhrf"]:
                    hrf_variables.append("{}".format(variable))
        script.extend(list(set(hrf_variables)))
        script.append("///")
        script.append('\nusing "${MY_PATH_IN}%s"' % hrf_dataset)
        script.append('\nsave "${MY_PATH_OUT}hrf.dta", replace \nclear')
        return heading + " ".join(script)

    def _render_create_master(self) -> str:
        """Render a "create master" section of the script file"""
        heading = "\n\n* * * CREATE MASTER * * *\n"
        key = "persnr" if self.settings["analysis_unit"] == "p" else "hhnrakt"
        script = '\nuse "${MY_PATH_OUT}pfad.dta", clear'
        script += (
            '\nmerge 1:1 %s hhnr using "${MY_PATH_OUT}hrf.dta", keep(master match) nogen'
            % key
        )
        script += '\nsave "${MY_PATH_OUT}master.dta", replace'
        return heading + script

    def _render_read_data(self) -> str:
        """Render a "read data" section of the script file"""
        heading = "\n\n* * * READ DATA * * *\n"
        temp = []
        for dataset in self.script_dict.values():
            if dataset["is_special"] == True:
                continue
            list_variables = set.copy(dataset["variables"])
            if dataset["analysis_unit"] == "p":
                for var in dataset["variables"]:
                    if var.endswith("hhnr"):
                        list_variables.remove(var)
            script = "\nuse %s" % " ".join(list_variables)
            script += ' using "${MY_PATH_IN}%s.dta", clear' % dataset["name"]
            script += '\nsave "${MY_PATH_OUT}%s.dta", replace' % dataset["name"]
            temp.append(script)
        return heading + "\n\n".join(temp)

    def _render_merge(self, _) -> str:
        """Render a "merge" section of the script file"""
        heading = "\n\n* * * MERGE DATA * * *\n"
        script = '\nuse   "${MY_PATH_OUT}master.dta", clear'
        for dataset in self.script_dict.values():
            if dataset["is_special"] == True:
                continue
            elif self.settings["analysis_unit"] != dataset["analysis_unit"] or (
                self.settings["analysis_unit"] == "h" and self.settings["balanced"] == "f"
            ):
                merge_factor = "m:1"
            else:
                merge_factor = "1:1"
            script += (
                '\nmerge %s %s using "${MY_PATH_OUT}%s.dta", keep(master match) nogen'
                % (merge_factor, dataset["merge_id"], dataset["name"])
            )
        return heading + script

    @staticmethod
    def _render_done() -> str:
        """Render an end section of the script file"""
        return (
            "\n\n"
            "* * * DONE * * *\n\n"
            'label data "paneldata.org"\n'
            'save "${MY_FILE_OUT}", replace\n'
            "desc\n\n"
            "log close"
        )
